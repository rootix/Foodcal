create type "public"."meal_type" as enum ('Dinner', 'Lunch');

create table "public"."meal" (
    "id" bigint generated by default as identity not null,
    "date" date not null,
    "notes" text,
    "recipe" bigint not null,
    "type" meal_type not null
);


alter table "public"."meal" enable row level security;

create table "public"."recipe" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "note" text,
    "tags" text[],
    "url" text,
    "deleted" boolean not null default false
);


alter table "public"."recipe" enable row level security;

CREATE UNIQUE INDEX meal_pkey ON public.meal USING btree (id);

CREATE UNIQUE INDEX recipe_name_key ON public.recipe USING btree (name);

CREATE UNIQUE INDEX recipe_pkey ON public.recipe USING btree (id);

alter table "public"."meal" add constraint "meal_pkey" PRIMARY KEY using index "meal_pkey";

alter table "public"."recipe" add constraint "recipe_pkey" PRIMARY KEY using index "recipe_pkey";

alter table "public"."meal" add constraint "meal_recipe_fkey" FOREIGN KEY (recipe) REFERENCES recipe(id) ON DELETE RESTRICT not valid;

alter table "public"."meal" validate constraint "meal_recipe_fkey";

alter table "public"."recipe" add constraint "recipe_name_key" UNIQUE using index "recipe_name_key";

create or replace view "public"."recipe_with_last_preparation" as  SELECT recipe.id,
    recipe.name,
    recipe.note,
    recipe.tags,
    recipe.url,
    recipe.deleted,
    ( SELECT max(meal.date) AS last_preparation
           FROM meal
          WHERE ((meal.recipe = recipe.id) AND (meal.date <= now()))) AS last_preparation
   FROM recipe
  WHERE (recipe.deleted = false);


create policy "Authenticated users only"
on "public"."meal"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Authenticated users only"
on "public"."recipe"
as permissive
for all
to authenticated
using (true)
with check (true);




